"""
COMPREHENSIVE QUANTUM ANTENNA ARRAY SIMULATION
Based on Mathematical Computation of Quantum Antenna Proposal

This code implements:
1. Classical vs Quantum array parameter comparison
2. GHZ state preparation and beamforming
3. 3D dipole radiation pattern visualization
4. Fisher Information analysis (quantum advantage)
5. Superradiance demonstration
6. Monte Carlo measurement statistics
7. Array factor calculations

Author: Based on ISRO Quantum Antenna Proposal
Date: January 2026
Compatible: Windows/Linux/Mac
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D
from scipy.linalg import expm
from scipy.stats import unitary_group
import warnings
import os
warnings.filterwarnings('ignore')

# Create output directory in current folder
OUTPUT_DIR = os.path.join(os.getcwd(), 'quantum_antenna_outputs')
os.makedirs(OUTPUT_DIR, exist_ok=True)
print(f"Output directory: {OUTPUT_DIR}")


class QuantumAntennaConstants:
    """Physical constants for quantum antenna simulation"""
    
    # Fundamental constants
    c = 3e8  # Speed of light [m/s]
    h = 6.626e-34  # Planck's constant [J·s]
    hbar = 1.055e-34  # Reduced Planck's constant [J·s]
    e = 1.602e-19  # Elementary charge [C]
    mu_0 = 4 * np.pi * 1e-7  # Permeability of free space [H/m]
    epsilon_0 = 8.854e-12  # Permittivity of free space [F/m]
    k_B = 1.381e-23  # Boltzmann constant [J/K]
    
    # Carbon Quantum Dot parameters
    CQD_dipole_moment = 30  # Debye (10-60 range)
    CQD_wavelength = 520e-9  # Green emission [m]
    CQD_linewidth = 75e-9  # Spectral width [m]
    CQD_quantum_yield = 0.6  # Efficiency
    CQD_decay_time = 10e-9  # Radiative lifetime [s]
    
    # NV Center parameters
    NV_wavelength = 637e-9  # Zero-phonon line [m]
    NV_dipole_moment = 5.2  # Debye
    NV_linewidth = 13e6  # Hz (lifetime limited)
    NV_zero_field_splitting = 2.87e9  # Hz
    NV_debye_waller = 0.04  # ZPL fraction
    NV_T2_coherence = 1e-3  # 1 ms [s]
    
    # Waveguide parameters
    Si3N4_refractive_index = 2.0
    SiO2_refractive_index = 1.46
    waveguide_width = 800e-9  # [m]
    waveguide_height = 400e-9  # [m]
    beta_factor_target = 0.9  # Coupling efficiency
    
    # Conversion factors
    Debye_to_Cm = 3.336e-30  # 1 Debye = 3.336e-30 C·m


class QuantumAntennaArray:
    """
    Quantum antenna array simulation class
    Implements full quantum mechanical treatment of N-emitter system
    """
    
    def __init__(self, N=4, wavelength=520e-9, spacing=0.5, emitter_type='CQD'):
        """
        Initialize quantum antenna array
        
        Parameters:
        -----------
        N : int
            Number of quantum emitters (qubits)
        wavelength : float
            Operating wavelength [m]
        spacing : float
            Element spacing in wavelengths
        emitter_type : str
            'CQD' or 'NV' for Carbon Quantum Dot or NV center
        """
        self.N = N
        self.wavelength = wavelength
        self.k = 2 * np.pi / wavelength  # Wavevector [rad/m]
        self.d = spacing * wavelength  # Physical spacing [m]
        self.emitter_type = emitter_type
        
        # Quantum state (complex amplitude vector of size 2^N)
        self.state = None
        self.initialize_state()
        
        # Physical parameters
        self.constants = QuantumAntennaConstants()
        self._set_emitter_parameters()
        
        # Calculate spontaneous emission rate
        self.calculate_emission_rate()
        
    def _set_emitter_parameters(self):
        """Set emitter-specific physical parameters"""
        if self.emitter_type == 'CQD':
            self.dipole_moment = self.constants.CQD_dipole_moment
            self.linewidth = self.constants.CQD_linewidth
            self.T2 = 1e-9  # Short coherence for CQD
        else:  # NV center
            self.dipole_moment = self.constants.NV_dipole_moment
            self.linewidth = self.constants.NV_linewidth
            self.T2 = self.constants.NV_T2_coherence
            
        # Convert dipole moment to SI units
        self.dipole_moment_SI = self.dipole_moment * self.constants.Debye_to_Cm
        
    def calculate_emission_rate(self):
        """
        Calculate spontaneous emission rate Γ₀
        Equation: Γ₀ = (μ²ω₀³)/(3πε₀ℏc³)
        """
        omega_0 = 2 * np.pi * self.constants.c / self.wavelength
        
        self.Gamma_0 = (self.dipole_moment_SI**2 * omega_0**3) / \
                       (3 * np.pi * self.constants.epsilon_0 * 
                        self.constants.hbar * self.constants.c**3)
        
        print(f"Spontaneous emission rate Γ₀ = {self.Gamma_0:.3e} Hz")
        print(f"Radiative lifetime τ = {1/self.Gamma_0:.3e} s")
        
    def initialize_state(self):
        """Initialize all qubits in |0⟩ state: |00...0⟩"""
        self.state = np.zeros(2**self.N, dtype=complex)
        self.state[0] = 1.0 + 0j
        
    def apply_hadamard(self, qubit):
        """
        Apply Hadamard gate to specific qubit
        H = (1/√2) [[1, 1], [1, -1]]
        """
        H = np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2)
        
        # Build full N-qubit unitary via tensor product
        ops = [H if q == qubit else np.eye(2, dtype=complex) 
               for q in range(self.N)]
        
        U = ops[0]
        for op in ops[1:]:
            U = np.kron(U, op)
            
        self.state = U @ self.state
        
    def apply_phase_gate(self, qubit, phi):
        """
        Apply phase rotation Rz(φ) to specific qubit
        Rz(φ) = [[e^(-iφ/2), 0], [0, e^(iφ/2)]]
        """
        Rz = np.array([[np.exp(-1j * phi / 2), 0],
                       [0, np.exp(1j * phi / 2)]], dtype=complex)
        
        ops = [Rz if q == qubit else np.eye(2, dtype=complex) 
               for q in range(self.N)]
        
        U = ops[0]
        for op in ops[1:]:
            U = np.kron(U, op)
            
        self.state = U @ self.state
        
    def apply_cnot(self, control, target):
        """
        Apply CNOT (controlled-NOT) gate
        CNOT = [[1,0,0,0], [0,1,0,0], [0,0,0,1], [0,0,1,0]]
        """
        U_full = np.eye(2**self.N, dtype=complex)
        
        for i in range(2**self.N):
            bits = [(i >> q) & 1 for q in range(self.N)]
            
            if bits[control] == 1:
                # Flip target bit
                j = i ^ (1 << target)
                temp = U_full[i, :].copy()
                U_full[i, :] = U_full[j, :]
                U_full[j, :] = temp
                
        self.state = U_full @ self.state
        
    def apply_controlled_phase(self, control, target, phi=np.pi):
        """
        Apply controlled-phase gate
        CZ adds phase φ to |11⟩ state
        """
        U_full = np.eye(2**self.N, dtype=complex)
        
        for i in range(2**self.N):
            bits = [(i >> q) & 1 for q in range(self.N)]
            
            if bits[control] == 1 and bits[target] == 1:
                U_full[i, i] *= np.exp(1j * phi)
                
        self.state = U_full @ self.state
    
    def prepare_ghz_state(self):
        """
        Prepare maximally entangled GHZ state
        |GHZ⟩ = (|00...0⟩ + |11...1⟩)/√2
        
        Circuit:
        q0: ─H─●─────────
              │
        q1: ──X─●────────
               │
        q2: ───X─●───────
                │
        q3: ────X────────
        """
        self.initialize_state()
        
        # Apply Hadamard to first qubit
        self.apply_hadamard(0)
        
        # Create entanglement chain with CNOT gates
        for q in range(self.N - 1):
            self.apply_cnot(q, q + 1)
            
        # Verify GHZ state structure
        expected_amplitude = 1.0 / np.sqrt(2)
        print(f"\nGHZ State Prepared:")
        print(f"  |00...0⟩ amplitude: {self.state[0]:.4f}")
        print(f"  |11...1⟩ amplitude: {self.state[-1]:.4f}")
        print(f"  Expected: ±{expected_amplitude:.4f}")
        
        # Calculate entanglement entropy
        entropy = self.calculate_entanglement_entropy()
        print(f"  Entanglement Entropy: {entropy:.4f} bits (max = 1.0)")
        
    def prepare_w_state(self):
        """
        Prepare W state (distributed entanglement)
        |W⟩ = (|100...0⟩ + |010...0⟩ + ... + |00...01⟩)/√N
        """
        self.initialize_state()
        
        # Equal superposition of all single-excitation states
        amplitude = 1.0 / np.sqrt(self.N)
        
        for n in range(self.N):
            # State with only nth qubit excited
            basis_idx = 1 << n  # 2^n
            self.state[basis_idx] = amplitude
            
        print(f"\nW State Prepared:")
        print(f"  Amplitude per single-excitation: {amplitude:.4f}")
        
    def calculate_entanglement_entropy(self):
        """
        Calculate von Neumann entropy for bipartite entanglement
        S = -Tr(ρ_A log₂ ρ_A)
        """
        # Partition: first qubit vs rest
        dim_A = 2
        dim_B = 2**(self.N - 1)
        
        # Reshape state for partial trace
        psi_matrix = self.state.reshape(dim_A, dim_B)
        
        # Reduced density matrix for subsystem A
        rho_A = np.outer(psi_matrix[0], psi_matrix[0].conj()) + \
                np.outer(psi_matrix[1], psi_matrix[1].conj())
        
        # Eigenvalues
        eigenvals = np.linalg.eigvalsh(rho_A)
        eigenvals = eigenvals[eigenvals > 1e-10]  # Remove numerical zeros
        
        # Von Neumann entropy
        entropy = -np.sum(eigenvals * np.log2(eigenvals))
        
        return entropy
    
    def apply_quantum_phase_shifts(self, target_angle):
        """
        Apply quantum phase shifts for beamsteering
        
        Phase for nth emitter: θ_n = n·k·d·sin(θ_target)
        Applied as Rz gates BEFORE photon emission
        
        Parameters:
        -----------
        target_angle : float
            Desired beam direction [radians]
        """
        for n in range(self.N):
            phase = n * self.k * self.d * np.sin(target_angle)
            self.apply_phase_gate(n, phase)
            
        print(f"\nApplied quantum phase shifts for θ = {np.degrees(target_angle):.1f}°")
        
    def calculate_radiation_pattern(self, theta_range=None):
        """
        Calculate far-field radiation pattern from quantum state
        
        Key equation: P(θ) = |⟨θ|ψ⟩|²
        
        For single-photon emission from N-qubit state, only basis states
        with exactly one excitation contribute.
        
        Returns:
        --------
        theta : array
            Angles in radians
        pattern : array
            Normalized radiation intensity
        """
        if theta_range is None:
            theta_range = np.linspace(-np.pi/2, np.pi/2, 361)
            
        pattern = np.zeros_like(theta_range, dtype=float)
        
        for i, theta in enumerate(theta_range):
            amplitude = 0j
            
            # Sum over computational basis states
            for basis_idx in range(2**self.N):
                bits = [(basis_idx >> q) & 1 for q in range(self.N)]
                
                # Only single-excitation states contribute to single-photon emission
                if sum(bits) == 1:
                    n = bits.index(1)  # Which emitter is excited
                    
                    # Phase from spatial position
                    phase_factor = np.exp(1j * n * self.k * self.d * np.sin(theta))
                    
                    # Quantum amplitude
                    amplitude += self.state[basis_idx] * phase_factor
                    
            # Radiation intensity
            pattern[i] = np.abs(amplitude)**2
            
        # Normalize
        if np.max(pattern) > 0:
            pattern /= np.max(pattern)
            
        return theta_range, pattern
        
    def calculate_classical_pattern(self, target_angle=0):
        """
        Calculate equivalent classical uniform linear array pattern
        
        Classical array factor:
        AF = sin²(Nψ/2) / (N²sin²(ψ/2))
        where ψ = kd(sinθ - sinθ₀)
        
        Returns:
        --------
        theta : array
            Angles in radians
        pattern : array
            Normalized radiation intensity
        """
        theta = np.linspace(-np.pi/2, np.pi/2, 361)
        
        psi = self.k * self.d * (np.sin(theta) - np.sin(target_angle))
        
        # Array factor (handle singularity at ψ=0)
        with np.errstate(divide='ignore', invalid='ignore'):
            af = np.sin(self.N * psi / 2) / (self.N * np.sin(psi / 2))
            af[psi == 0] = 1.0
        
        pattern = np.abs(af)**2
        pattern /= np.max(pattern)
        
        return theta, pattern

    
    def calculate_3d_radiation_pattern(self, n_theta=91, n_phi=181):
        """
        Calculate 3D radiation pattern in spherical coordinates
        
        Parameters:
        -----------
        n_theta : int
            Number of elevation samples (0 to π)
        n_phi : int
            Number of azimuth samples (0 to 2π)
            
        Returns:
        --------
        theta, phi : arrays
            Spherical coordinate grids
        intensity : array
            Radiation intensity at each (θ, φ)
        """
        theta = np.linspace(0, np.pi, n_theta)
        phi = np.linspace(0, 2*np.pi, n_phi)
        theta_grid, phi_grid = np.meshgrid(theta, phi)
        
        intensity = np.zeros_like(theta_grid, dtype=float)
        
        # For linear array along x-axis, pattern is symmetric in φ
        # Main variation is in θ (elevation from x-axis)
        
        for i in range(n_phi):
            for j in range(n_theta):
                t = theta_grid[i, j]
                p = phi_grid[i, j]
                
                # Direction vector
                k_vec = np.array([
                    np.sin(t) * np.cos(p),
                    np.sin(t) * np.sin(p),
                    np.cos(t)
                ])
                
                # Calculate quantum amplitude
                amplitude = 0j
                
                for basis_idx in range(2**self.N):
                    bits = [(basis_idx >> q) & 1 for q in range(self.N)]
                    
                    if sum(bits) == 1:
                        n = bits.index(1)
                        
                        # Position of nth element along x-axis
                        r_n = np.array([n * self.d, 0, 0])
                        
                        # Phase from k·r
                        phase = np.dot(self.k * k_vec, r_n)
                        
                        amplitude += self.state[basis_idx] * np.exp(1j * phase)
                        
                intensity[i, j] = np.abs(amplitude)**2
                
        # Normalize
        intensity /= np.max(intensity)
        
        return theta_grid, phi_grid, intensity
    
    def demonstrate_quantum_advantage(self):
        """
        Demonstrate quantum advantage in angle estimation
        
        Compare:
        1. Classical Fisher Information: F_c = N·(kd)²
        2. Quantum Fisher Information: F_q = N²·(kd)²
        
        Quantum Cramér-Rao Bound: Δθ ≥ 1/√(M·F_q)
        Classical Cramér-Rao Bound: Δθ ≥ 1/√(M·F_c)
        
        Enhancement: N-fold better precision
        """
        print("\n" + "="*70)
        print("QUANTUM ADVANTAGE ANALYSIS: ANGLE ESTIMATION")
        print("="*70)
        
        # Fisher Information calculation
        sensitivity_factor = (self.k * self.d)**2
        
        # Classical Fisher Information (independent measurements)
        FI_classical = self.N * sensitivity_factor / 2
        CRB_classical = 1 / FI_classical
        
        # Quantum Fisher Information (entangled measurements)
        FI_quantum = (self.N * self.k * self.d)**2
        QCRB_quantum = 1 / FI_quantum
        
        print(f"\n1. Fisher Information Comparison:")
        print(f"   Classical FI: {FI_classical:.4e} rad⁻²")
        print(f"   Quantum FI:   {FI_quantum:.4e} rad⁻²")
        print(f"   Ratio (Q/C):  {FI_quantum/FI_classical:.2f}×")
        
        print(f"\n2. Cramér-Rao Bounds (single measurement):")
        print(f"   Classical CRB: {np.degrees(np.sqrt(CRB_classical)):.6f}°")
        print(f"   Quantum CRB:   {np.degrees(np.sqrt(QCRB_quantum)):.6f}°")
        
        improvement = np.sqrt(CRB_classical / QCRB_quantum)
        print(f"\n3. Quantum Advantage Factor: {improvement:.2f}×")
        print(f"   (Theoretical prediction: N = {self.N}×)")
        
        # Monte Carlo simulation
        print(f"\n4. Monte Carlo Verification:")
        num_trials = 1000
        true_angle = 0.05  # Small offset from broadside
        
        classical_errors = []
        quantum_errors = []
        
        for _ in range(num_trials):
            # Classical estimation (independent phase measurements)
            noise = np.random.normal(0, 0.1, self.N)
            measured_phases = true_angle * self.k * self.d * np.arange(self.N) + noise
            est_classical = np.arcsin(np.mean(np.diff(measured_phases)) / (self.k * self.d))
            classical_errors.append(est_classical - true_angle)
            
            # Quantum estimation (correlated measurements via entanglement)
            quantum_noise = np.random.normal(0, 0.1 / np.sqrt(self.N))
            measured_quantum = true_angle * self.N * self.k * self.d + quantum_noise
            est_quantum = np.arcsin(measured_quantum / (self.N * self.k * self.d))
            quantum_errors.append(est_quantum - true_angle)
            
        rmse_classical = np.sqrt(np.mean(np.array(classical_errors)**2))
        rmse_quantum = np.sqrt(np.mean(np.array(quantum_errors)**2))
        
        print(f"   Classical RMSE: {np.degrees(rmse_classical):.6f}°")
        print(f"   Quantum RMSE:   {np.degrees(rmse_quantum):.6f}°")
        print(f"   Measured Improvement: {rmse_classical/rmse_quantum:.2f}×")
        
        return {
            'FI_classical': FI_classical,
            'FI_quantum': FI_quantum,
            'improvement_factor': improvement,
            'rmse_classical': rmse_classical,
            'rmse_quantum': rmse_quantum,
            'classical_errors': classical_errors,
            'quantum_errors': quantum_errors
        }
        
    def demonstrate_superradiance(self):
        """
        Demonstrate superradiance (Dicke enhancement)
        
        For GHZ state: Γ_super = N² · Γ₀ (in specific directions)
        Classical:     Γ_classical = N · Γ₀
        
        Enhancement factor: N
        """
        print("\n" + "="*70)
        print("SUPERRADIANCE DEMONSTRATION")
        print("="*70)
        
        # Calculate emission rates
        Gamma_classical = self.N * self.Gamma_0
        Gamma_super = self.N**2 * self.Gamma_0
        
        print(f"\n1. Emission Rates:")
        print(f"   Single emitter: Γ₀ = {self.Gamma_0:.3e} Hz")
        print(f"   Classical array: Γ_c = N·Γ₀ = {Gamma_classical:.3e} Hz")
        print(f"   Superradiant: Γ_s = N²·Γ₀ = {Gamma_super:.3e} Hz")
        
        enhancement = Gamma_super / Gamma_classical
        print(f"\n2. Superradiance Enhancement: {enhancement:.1f}×")
        print(f"   (Equal to N = {self.N})")
        
        # Radiative lifetimes
        tau_0 = 1 / self.Gamma_0
        tau_super = 1 / Gamma_super
        
        print(f"\n3. Radiative Lifetimes:")
        print(f"   Single emitter: τ₀ = {tau_0:.3e} s")
        print(f"   Superradiant: τ_s = τ₀/N² = {tau_super:.3e} s")
        
        return {
            'Gamma_0': self.Gamma_0,
            'Gamma_classical': Gamma_classical,
            'Gamma_super': Gamma_super,
            'enhancement': enhancement
        }

def plot_classical_vs_quantum_comparison(qantenna, angles=[0, np.pi/8, np.pi/4]):
    """
    Side-by-side comparison of classical and quantum array patterns
    """
    fig, axes = plt.subplots(len(angles), 2, figsize=(14, 4*len(angles)))
    if len(angles) == 1:
        axes = axes.reshape(1, -1)
    
    for idx, angle in enumerate(angles):
        # Quantum pattern
        qantenna.prepare_ghz_state()
        qantenna.apply_quantum_phase_shifts(angle)
        theta_q, pattern_q = qantenna.calculate_radiation_pattern()
        
        # Classical pattern
        theta_c, pattern_c = qantenna.calculate_classical_pattern(angle)
        
        # Plot quantum
        axes[idx, 0].plot(np.degrees(theta_q), 10*np.log10(pattern_q + 1e-10), 
                         'b-', linewidth=2, label='Quantum (GHZ)')
        axes[idx, 0].set_xlabel('Angle (degrees)', fontsize=12)
        axes[idx, 0].set_ylabel('Normalized Power (dB)', fontsize=12)
        axes[idx, 0].set_title(f'Quantum Array @ θ={np.degrees(angle):.1f}°', 
                              fontsize=14, fontweight='bold')
        axes[idx, 0].grid(True, alpha=0.3)
        axes[idx, 0].set_ylim([-40, 5])
        axes[idx, 0].legend(fontsize=11)
        
        # Plot classical
        axes[idx, 1].plot(np.degrees(theta_c), 10*np.log10(pattern_c + 1e-10), 
                         'r-', linewidth=2, label='Classical')
        axes[idx, 1].set_xlabel('Angle (degrees)', fontsize=12)
        axes[idx, 1].set_ylabel('Normalized Power (dB)', fontsize=12)
        axes[idx, 1].set_title(f'Classical Array @ θ={np.degrees(angle):.1f}°', 
                              fontsize=14, fontweight='bold')
        axes[idx, 1].grid(True, alpha=0.3)
        axes[idx, 1].set_ylim([-40, 5])
        axes[idx, 1].legend(fontsize=11)
        
    plt.tight_layout()
    filepath = os.path.join(OUTPUT_DIR, 'classical_vs_quantum_comparison.png')
    plt.savefig(filepath, dpi=300, bbox_inches='tight')
    print(f"\n✓ Saved: {filepath}")
    plt.show()

def plot_3d_radiation_pattern(qantenna):
    """
    3D visualization of quantum antenna radiation pattern
    """
    print("\nGenerating 3D radiation pattern...")
    
    # Prepare GHZ state
    qantenna.prepare_ghz_state()
    
    # Calculate 3D pattern
    theta_grid, phi_grid, intensity = qantenna.calculate_3d_radiation_pattern(
        n_theta=91, n_phi=181)
    
    # Convert to Cartesian coordinates
    X = intensity * np.sin(theta_grid) * np.cos(phi_grid)
    Y = intensity * np.sin(theta_grid) * np.sin(phi_grid)
    Z = intensity * np.cos(theta_grid)
    
    # Create figure
    fig = plt.figure(figsize=(14, 10))
    ax = fig.add_subplot(111, projection='3d')
    
    # Plot surface
    surf = ax.plot_surface(X, Y, Z, 
                          cmap='plasma',
                          alpha=0.9,
                          linewidth=0,
                          antialiased=True,
                          vmin=0, vmax=1)
    
    # Add array elements along x-axis
    for n in range(qantenna.N):
        x_pos = n * qantenna.d / qantenna.wavelength  # Normalized
        ax.scatter([x_pos], [0], [0], s=150, c='red', marker='o', 
                  edgecolors='black', linewidths=2,
                  label=f'Emitter {n}' if n == 0 else '')
    
    # Formatting
    ax.set_xlabel('X (wavelengths)', fontsize=12, fontweight='bold')
    ax.set_ylabel('Y (wavelengths)', fontsize=12, fontweight='bold')
    ax.set_zlabel('Z (wavelengths)', fontsize=12, fontweight='bold')
    ax.set_title(f'3D Quantum Antenna Radiation Pattern\n' + 
                f'N={qantenna.N} Emitters, GHZ State, λ={qantenna.wavelength*1e9:.0f} nm',
                fontsize=14, fontweight='bold')
    
    # Color bar
    cbar = plt.colorbar(surf, ax=ax, shrink=0.5, aspect=10)
    cbar.set_label('Normalized Intensity', fontsize=11, fontweight='bold')
    
    ax.legend(loc='upper right', fontsize=10)
    
    # Set viewing angle
    ax.view_init(elev=20, azim=45)
    
    filepath = os.path.join(OUTPUT_DIR, '3d_radiation_pattern.png')
    plt.savefig(filepath, dpi=300, bbox_inches='tight')
    print(f"✓ Saved: {filepath}")
    plt.show()

def plot_quantum_advantage_analysis(advantage_results):
    """
    Visualize quantum advantage in angle estimation
    """
    fig, axes = plt.subplots(1, 2, figsize=(14, 5))
    
    # Plot 1: Error distributions
    axes[0].hist(np.degrees(advantage_results['classical_errors']), 
                bins=40, alpha=0.7, color='red', 
                label=f"Classical (σ={np.degrees(advantage_results['rmse_classical']):.4f}°)")
    axes[0].hist(np.degrees(advantage_results['quantum_errors']), 
                bins=40, alpha=0.7, color='blue', 
                label=f"Quantum (σ={np.degrees(advantage_results['rmse_quantum']):.4f}°)")
    axes[0].set_xlabel('Estimation Error (degrees)', fontsize=12, fontweight='bold')
    axes[0].set_ylabel('Frequency', fontsize=12, fontweight='bold')
    axes[0].set_title('Angle Estimation Error Distribution', 
                     fontsize=14, fontweight='bold')
    axes[0].legend(fontsize=11)
    axes[0].grid(True, alpha=0.3)
    
    # Plot 2: Fisher Information comparison
    categories = ['Classical\nFisher Info', 'Quantum\nFisher Info']
    values = [advantage_results['FI_classical'], advantage_results['FI_quantum']]
    colors = ['red', 'blue']
    
    bars = axes[1].bar(categories, values, color=colors, alpha=0.7, 
                      edgecolor='black', linewidth=2)
    axes[1].set_ylabel('Fisher Information (rad⁻²)', fontsize=12, fontweight='bold')
    axes[1].set_title(f"Fisher Information Comparison\n" + 
                     f"Quantum Advantage: {advantage_results['improvement_factor']:.1f}×",
                     fontsize=14, fontweight='bold')
    axes[1].grid(True, alpha=0.3, axis='y')
    
    # Add value labels on bars
    for bar, val in zip(bars, values):
        height = bar.get_height()
        axes[1].text(bar.get_x() + bar.get_width()/2., height,
                    f'{val:.2e}',
                    ha='center', va='bottom', fontsize=11, fontweight='bold')
    
    plt.tight_layout()
    filepath = os.path.join(OUTPUT_DIR, 'quantum_advantage_analysis.png')
    plt.savefig(filepath, dpi=300, bbox_inches='tight')
    print(f"✓ Saved: {filepath}")
    plt.show()

def plot_superradiance_demonstration(qantenna, super_results):
    """
    Visualize superradiance enhancement
    """
    fig, axes = plt.subplots(1, 2, figsize=(14, 5))
    
    # Plot 1: Emission rate comparison
    N_range = np.arange(1, 11)
    gamma_classical = N_range * super_results['Gamma_0']
    gamma_super = N_range**2 * super_results['Gamma_0']
    
    axes[0].plot(N_range, gamma_classical / super_results['Gamma_0'], 
                'r-o', linewidth=2, markersize=8, label='Classical (N·Γ₀)')
    axes[0].plot(N_range, gamma_super / super_results['Gamma_0'], 
                'b-s', linewidth=2, markersize=8, label='Superradiant (N²·Γ₀)')
    axes[0].axvline(qantenna.N, color='green', linestyle='--', linewidth=2,
                   label=f'Current N={qantenna.N}')
    axes[0].set_xlabel('Number of Emitters (N)', fontsize=12, fontweight='bold')
    axes[0].set_ylabel('Emission Rate (Γ/Γ₀)', fontsize=12, fontweight='bold')
    axes[0].set_title('Superradiance: N² Scaling', fontsize=14, fontweight='bold')
    axes[0].legend(fontsize=11)
    axes[0].grid(True, alpha=0.3)
    axes[0].set_yscale('log')
    
    # Plot 2: Lifetime comparison
    categories = ['Single\nEmitter', 'Classical\nArray', 'Superradiant\nArray']
    lifetimes = [1/super_results['Gamma_0'], 
                1/super_results['Gamma_classical'],
                1/(super_results['Gamma_super'])]
    colors = ['gray', 'red', 'blue']
    
    bars = axes[1].bar(categories, np.array(lifetimes)*1e9, color=colors, 
                      alpha=0.7, edgecolor='black', linewidth=2)
    axes[1].set_ylabel('Radiative Lifetime (ns)', fontsize=12, fontweight='bold')
    axes[1].set_title(f'Radiative Lifetime Comparison\n' + 
                     f'N={qantenna.N} Emitters',
                     fontsize=14, fontweight='bold')
    axes[1].set_yscale('log')
    axes[1].grid(True, alpha=0.3, axis='y')
    
    # Add value labels
    for bar, val in zip(bars, lifetimes):
        height = bar.get_height()
        axes[1].text(bar.get_x() + bar.get_width()/2., height,
                    f'{val*1e9:.2f} ns',
                    ha='center', va='bottom', fontsize=10, fontweight='bold')
    
    plt.tight_layout()
    filepath = os.path.join(OUTPUT_DIR, 'superradiance_demonstration.png')
    plt.savefig(filepath, dpi=300, bbox_inches='tight')
    print(f"✓ Saved: {filepath}")
    plt.show()

def plot_array_parameters_table(qantenna):
    """
    Display comprehensive array parameters in table format
    """
    fig, ax = plt.subplots(figsize=(12, 8))
    ax.axis('tight')
    ax.axis('off')
    
    # Prepare data
    parameters = [
        ['SYSTEM CONFIGURATION', '', ''],
        ['Number of Emitters (N)', f'{qantenna.N}', 'qubits'],
        ['Wavelength (λ)', f'{qantenna.wavelength*1e9:.1f}', 'nm'],
        ['Element Spacing (d)', f'{qantenna.d/qantenna.wavelength:.2f}λ', f'{qantenna.d*1e9:.1f} nm'],
        ['Array Length', f'{(qantenna.N-1)*qantenna.d/qantenna.wavelength:.2f}λ', 
         f'{(qantenna.N-1)*qantenna.d*1e9:.1f} nm'],
        ['Emitter Type', f'{qantenna.emitter_type}', ''],
        ['', '', ''],
        ['EMITTER PARAMETERS', '', ''],
        ['Dipole Moment (μ)', f'{qantenna.dipole_moment:.1f}', 'Debye'],
        ['Dipole Moment (SI)', f'{qantenna.dipole_moment_SI:.2e}', 'C·m'],
        ['Spontaneous Emission (Γ₀)', f'{qantenna.Gamma_0:.3e}', 'Hz'],
        ['Radiative Lifetime (τ₀)', f'{1/qantenna.Gamma_0*1e9:.2f}', 'ns'],
        ['Coherence Time (T₂)', f'{qantenna.T2*1e6:.2f}', 'μs'],
        ['', '', ''],
        ['CLASSICAL ARRAY METRICS', '', ''],
        ['Peak Directivity', f'{10*np.log10(2*qantenna.N):.1f}', 'dBi'],
        ['Beamwidth (HPBW)', f'{np.degrees(0.886*qantenna.wavelength/(qantenna.N*qantenna.d)):.1f}', '°'],
        ['First Null', f'{np.degrees(qantenna.wavelength/(qantenna.N*qantenna.d)):.1f}', '°'],
        ['', '', ''],
        ['QUANTUM ENHANCEMENTS', '', ''],
        ['Fisher Info Enhancement', f'{qantenna.N}', '×'],
        ['Angle Resolution Enhancement', f'{qantenna.N}', '×'],
        ['Superradiance Factor', f'{qantenna.N**2}', '×'],
        ['Entanglement Capacity', '1.0', 'bits'],
    ]
    
    # Create table
    table = ax.table(cellText=parameters, 
                    colWidths=[0.5, 0.3, 0.2],
                    cellLoc='left',
                    loc='center',
                    bbox=[0, 0, 1, 1])
    
    table.auto_set_font_size(False)
    table.set_fontsize(10)
    table.scale(1, 2)
    
    # Style header rows
    for i in [0, 7, 14, 18]:
        for j in range(3):
            cell = table[(i, j)]
            cell.set_facecolor('#4472C4')
            cell.set_text_props(weight='bold', color='white')
    
    # Alternate row colors
    for i in range(len(parameters)):
        if i not in [0, 7, 14, 18]:
            for j in range(3):
                cell = table[(i, j)]
                if i % 2 == 0:
                    cell.set_facecolor('#E7E6E6')
                else:
                    cell.set_facecolor('#FFFFFF')
    
    plt.title('Quantum Antenna Array Parameters', 
             fontsize=16, fontweight='bold', pad=20)
    
    filepath = os.path.join(OUTPUT_DIR, 'array_parameters_table.png')
    plt.savefig(filepath, dpi=300, bbox_inches='tight')
    print(f"✓ Saved: {filepath}")
    plt.show()

def plot_dipole_coupling_visualization(qantenna):
    """
    Visualize dipole-dipole coupling strength vs distance
    """
    # Distance range (in wavelengths)
    r_lambda = np.logspace(-1, 1, 200)  # 0.1λ to 10λ
    r = r_lambda * qantenna.wavelength
    kr = qantenna.k * r
    
    # Coupling strength components
    # V(r) = (μ₀μ²ω₀²)/(4πℏ) · F(kr)/r
    # F(kr) has near-field (1/r³) and far-field (1/r) terms
    
    # Near-field term (∝ 1/r³)
    V_near = 1 / (kr)**3
    
    # Far-field term (∝ 1/r)
    V_far = 1 / kr
    
    # Total (simplified)
    V_total = np.sqrt(V_near**2 + V_far**2)
    
    # Normalize
    V_near /= V_near[0]
    V_far /= V_far[0]
    V_total /= V_total[0]
    
    # Plot
    fig, ax = plt.subplots(figsize=(12, 7))
    
    ax.loglog(r_lambda, V_near, 'b--', linewidth=2, label='Near-field (∝ 1/r³)')
    ax.loglog(r_lambda, V_far, 'r--', linewidth=2, label='Far-field (∝ 1/r)')
    ax.loglog(r_lambda, V_total, 'g-', linewidth=3, label='Total coupling')
    
    # Mark transitions
    ax.axvline(1/(2*np.pi), color='orange', linestyle=':', linewidth=2, 
              label='Transition (kr ≈ 1)')
    
    # Mark current spacing
    current_spacing = qantenna.d / qantenna.wavelength
    ax.axvline(current_spacing, color='purple', linestyle='-', linewidth=2,
              label=f'Array spacing ({current_spacing:.2f}λ)')
    
    ax.set_xlabel('Distance (wavelengths)', fontsize=12, fontweight='bold')
    ax.set_ylabel('Normalized Coupling Strength', fontsize=12, fontweight='bold')
    ax.set_title('Dipole-Dipole Coupling vs Distance\n' + 
                f'λ = {qantenna.wavelength*1e9:.0f} nm',
                fontsize=14, fontweight='bold')
    ax.legend(fontsize=11, loc='upper right')
    ax.grid(True, alpha=0.3, which='both')
    
    plt.tight_layout()
    filepath = os.path.join(OUTPUT_DIR, 'dipole_coupling_distance.png')
    plt.savefig(filepath, dpi=300, bbox_inches='tight')
    print(f"✓ Saved: {filepath}")
    plt.show()

def plot_monte_carlo_measurement_statistics(qantenna, target_angle=0, num_shots=5000):
    """
    Simulate quantum measurement statistics via Monte Carlo
    """
    print(f"\nRunning Monte Carlo simulation ({num_shots} measurements)...")
    
    # Prepare quantum state
    qantenna.prepare_ghz_state()
    qantenna.apply_quantum_phase_shifts(target_angle)
    
    # Calculate probability distribution
    theta_range = np.linspace(-np.pi/2, np.pi/2, 361)
    _, pattern = qantenna.calculate_radiation_pattern(theta_range)
    
    # Normalize to probability
    prob = pattern / np.sum(pattern)
    
    # Monte Carlo sampling
    measured_angles = np.random.choice(theta_range, size=num_shots, p=prob)
    
    # Plot
    fig, axes = plt.subplots(1, 2, figsize=(14, 5))
    
    # Histogram of measurements
    axes[0].hist(np.degrees(measured_angles), bins=50, density=True, 
                alpha=0.7, color='blue', edgecolor='black', linewidth=1.2,
                label=f'{num_shots} measurements')
    axes[0].plot(np.degrees(theta_range), prob * 180 / np.pi, 
                'r-', linewidth=2, label='Theoretical P(θ)')
    axes[0].set_xlabel('Angle (degrees)', fontsize=12, fontweight='bold')
    axes[0].set_ylabel('Probability Density', fontsize=12, fontweight='bold')
    axes[0].set_title('Quantum Measurement Statistics\n(Monte Carlo Simulation)', 
                     fontsize=14, fontweight='bold')
    axes[0].legend(fontsize=11)
    axes[0].grid(True, alpha=0.3)
    
    # Cumulative measurements
    cumulative_avg = np.cumsum(measured_angles) / np.arange(1, num_shots+1)
    
    axes[1].plot(np.degrees(cumulative_avg), 'b-', linewidth=2, alpha=0.7)
    axes[1].axhline(np.degrees(target_angle), color='red', linestyle='--', 
                   linewidth=2, label=f'True angle: {np.degrees(target_angle):.1f}°')
    axes[1].set_xlabel('Number of Measurements', fontsize=12, fontweight='bold')
    axes[1].set_ylabel('Cumulative Mean Angle (degrees)', fontsize=12, fontweight='bold')
    axes[1].set_title('Convergence to True Beam Direction', 
                     fontsize=14, fontweight='bold')
    axes[1].legend(fontsize=11)
    axes[1].grid(True, alpha=0.3)
    
    plt.tight_layout()
    filepath = os.path.join(OUTPUT_DIR, 'monte_carlo_statistics.png')
    plt.savefig(filepath, dpi=300, bbox_inches='tight')
    print(f"✓ Saved: {filepath}")
    plt.show()
    
    return measured_angles

def main():
    """
    Main execution: Comprehensive quantum antenna simulation
    """
    print("="*70)
    print(" QUANTUM ANTENNA ARRAY SIMULATION")
    print(" Mathematical Computation of Quantum Antenna Proposal")
    print(" ISRO Space Technology Incubation Centre")
    print("="*70)
    
    # Initialize quantum antenna array
    print("\n>>> Initializing Quantum Antenna Array...")
    N = 4
    wavelength = 520e-9  # Green emission (CQD)
    spacing = 0.5  # Half-wavelength spacing
    
    qantenna = QuantumAntennaArray(N=N, wavelength=wavelength, 
                                   spacing=spacing, emitter_type='CQD')
    
    print(f"\nArray Configuration:")
    print(f"  N = {N} emitters")
    print(f"  λ = {wavelength*1e9:.0f} nm")
    print(f"  d = {spacing}λ = {qantenna.d*1e9:.1f} nm")
    print(f"  Array length = {(N-1)*qantenna.d*1e9:.1f} nm")
    
    # 1. Classical vs Quantum Comparison
    print("\n" + "="*70)
    print("1. CLASSICAL VS QUANTUM ARRAY COMPARISON")
    print("="*70)
    plot_classical_vs_quantum_comparison(qantenna, angles=[0, np.pi/8, np.pi/4])
    
    # 2. 3D Radiation Pattern
    print("\n" + "="*70)
    print("2. 3D RADIATION PATTERN VISUALIZATION")
    print("="*70)
    plot_3d_radiation_pattern(qantenna)
    
    # 3. Quantum Advantage Analysis
    print("\n" + "="*70)
    print("3. QUANTUM ADVANTAGE DEMONSTRATION")
    print("="*70)
    advantage_results = qantenna.demonstrate_quantum_advantage()
    plot_quantum_advantage_analysis(advantage_results)
    
    # 4. Superradiance
    print("\n" + "="*70)
    print("4. SUPERRADIANCE ANALYSIS")
    print("="*70)
    super_results = qantenna.demonstrate_superradiance()
    plot_superradiance_demonstration(qantenna, super_results)
    
    # 5. Array Parameters
    print("\n" + "="*70)
    print("5. ARRAY PARAMETERS TABLE")
    print("="*70)
    plot_array_parameters_table(qantenna)
    
    # 6. Dipole Coupling
    print("\n" + "="*70)
    print("6. DIPOLE-DIPOLE COUPLING ANALYSIS")
    print("="*70)
    plot_dipole_coupling_visualization(qantenna)
    
    # 7. Monte Carlo Statistics
    print("\n" + "="*70)
    print("7. QUANTUM MEASUREMENT STATISTICS")
    print("="*70)
    measured_angles = plot_monte_carlo_measurement_statistics(qantenna, 
                                                              target_angle=0, 
                                                              num_shots=5000)
    
    print("\n" + "="*70)
    print(" SIMULATION COMPLETE")
    print("="*70)
    print("\nGenerated Figures:")
    print("  1. classical_vs_quantum_comparison.png")
    print("  2. 3d_radiation_pattern.png")
    print("  3. quantum_advantage_analysis.png")
    print("  4. superradiance_demonstration.png")
    print("  5. array_parameters_table.png")
    print("  6. dipole_coupling_distance.png")
    print("  7. monte_carlo_statistics.png")
    print(f"\nAll outputs saved to: {OUTPUT_DIR}")
    print("="*70)

if __name__ == "__main__":
    main()